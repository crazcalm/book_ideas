# Poker hands
We have learned how to sort of list of items into one logical arrangement. Admittedly, this covers the practical cases of sorting. Moving towards the impractical, let's explore how we handle sorting into one of many logical arrangments.

Poker is great example of this becasue, when we compare poker hands, we need to be able to sort the hand so that all the high value cards are in the front. The poker hand type dictates the logical arrangement that your sort needs to adhere to. Below is a list of poker hands.

(Add list of poker hands)

If we had a One Pair hand <3,2,1,5,2>, we would want to sort our hand so that the pair is at the front of the list, followed by the rest of the cards in high card order <2,2,5,3,1>. This ordering makes it easy to compare One Pair hands. For example, if hand one is <2,2,5,3,1> and hand two is <6,6,3,2,1>, We can compare each card in the hands from left to right and know which hand it greater. This technique works even when two hands have the same pair; <2,2,5,3,1> vs <2,2,6,2,1>.

If we had a High Card poker hand, we would then want to sort our cards solely by our high cards. So a High card hand of <4,8,J,A,5> would become <A,J,8,5,4>. Based on the examples of the One Pair hand and the High Card hand, we see that our sorting function is dictated by our poker hand type.

## Creating Cards

In order to create poker hands, we first need to create cards.

```rust
enum Suite {
    Heart,
    Club,
    Spade,
    Diamond,
}

struct Card {
    name: u8,
    suite: Suite,
}

fn main(){}
```

In our example, we created a Card Struct that has two fields; name and suite. The name field is of type `u8` and represents the Rank of the card. The suite field is represented by the Suite Enum, which has 4 variants; Heart, Club, Spade and Diamond.

To make the cards visually less confusing, we are going to implement the Debug Trait and make sure that the numbers 11 - 14 represent Jack - Ace.

```rust,noplayground
impl fmt::Debug for Card {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
	let name = match self.name {
	    x @ 2 ..=10 => x.to_string(),
	    11 => "J".to_string(),
	    12 => "Q".to_string(),
	    13 => "K".to_string(),
	    14 => "A".to_string(),
	    _ => panic!("number {:?} is not a valid card number", &self.name),
	};

	f.debug_struct("Card")
	    .field("name", &name)
	    .field("suite", &self.suite)
	    .finish()
    }
}
```
In our `fmt` method, we used a match statement on the Card.name field to create our wanted string representation the card's rank. If the value of Card.name is between 2 and 10, then we will convert the number to a String. We accomplish this by using the `@` symbol in our match statement. The code `x @ 2 ..= 10` allows use to check if the value of Card.name is in the range of `2 ..= 10` and, if so, bind that value to `x`. Once that value has been vound to `x`, we use the match arm to convert `x` into a String and return it. If the value of Card.name is 11, 12, 13 or 14, it will match with its specific match arm. All other values, which are not valid cards in poker, will be caught by the `_` case and raise an error. Once we have our local representation of our card's rank, we pass it our formatter to be displayed.
