<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
	<head>
		<title>Chapter 1. Introduction</title>
		<link rel="stylesheet" type="text/css" href="css/epub.css" />
	</head>
	<body>
		<section class="chapter" epub:type="chapter" role="doc-chapter" aria-labelledby="c1_h" id="introduction">
		  <h2 id="c1_h" class="title">Chapter 1: Apples to Apples</h2>

		  <p>Sorting is the act of arranging items into a logical orger. That said, in order to know which item goes in front of the other item, they much be compared. This means that the first step in sorting is making sure the items you want to sort can be compared</p>

		  <p>In Rust, we can only compare items of the same type. For example, consider the comparision <code>1 > 'a'</code>. 1 is a number and 'a' is a character. They are not the same type. As such, they cannot be compared.</p>

		  <code>println!("{} > {} = {}", 1, 'a', 1 > 'a');</code>

		  <p>1 and 2 are both numbers, but Rust has different types of numbers. If 1 is of type u8 and 2 is of type i32, then we cannot compare them.</p>

		  <pre>let one: u8 = 1;
let two: i32 = 2;

println!("{} > {} = {}", one, two, one > two);</pre>

		  <p>It is only when 1 and 2 are of the same type that we can compare them.</p>

		  <pre>let one: u8 = 1;
let two: u8 = 2;
println!("{} > {} = {}", one, two, one > two);</pre>


		  <p>For simple examples, we do not have to specify the type because Rust has type inference, which means, in the absense of an explicit type, the compilier will make an educated guess at which type to use. Coming back the our comparison of <code>1 > 2</code>, the compilier will note that these numbers are being compared and set them to be the same type</p>

		  <pre>let one = 1;
let two = 2;

		    println!("{} > {} = {}", one, two, one > two);</pre>
		      
		</section>
	</body>
</html>
