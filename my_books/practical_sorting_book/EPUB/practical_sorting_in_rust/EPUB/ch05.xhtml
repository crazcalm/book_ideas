<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en"
	lang="en">
	<head>
		<title>Chapter 4: Common Uses For Sorting</title>
		<link rel="stylesheet" type="text/css" href="css/epub.css" />
	</head>
	<body>
		<section class="chapter" epub:type="chapter" role="doc-chapter" aria-labelledby="c4_h" id="conclusion">
		  <h2 id="c4_h" class="title">Chapter 4: Common Uses For Sorting</h2>

		  <p>Sorting is typcally done for two reasons: comparing and search. When comparing lists of elements, order matters because equality means that every element at each index is equal. For example, <code>[1, 2, 3]</code> is not equal to <code>[2, 3, 1]</code> even though they contain the same elements.</p>

		  <pre>let a = vec![1,2,3,4];
let b = vec![2,3,1,4];

println("{:?} == {:?} => {}", a, b, a == b);
</pre>


		  <p>However, if we sort both lists prior to checking for equality, we ensure that the elements of both lists have ben ordered in the manner. This gives us the expectation that, as long as both lists have the same elements, the sorted order of the list should be equal as well.</p>

		  <pre>let mut a = vec![1,2,3,4];
let mut b = vec![2,3,1,4];

a.sort()
b.sort()

println("{:?} == {:?} => {}", a, b, a == b);
</pre>

		  <p>When we talk about search we usually are talking about searching for an element or a group of elements from a collection of elements via a specific criteria. For example, given the list <code>[2, 9, 3, 1, 8, 7, 6, 9, 0]</code>, asking if the number 5 is in the list is  single element search and asking for all the values less than 5 is an example of searching for a group of elements via a specific criteria.</p>

		  <p>Sorting makes searching easier because, if your collection of elements are sorted, then you know that you can leverage the rules of the logical arrangement to reach your answer faster. For example, sorting <code>[2, 9, 3, 1, 8, 7, 6, 9, 0]</code> in ascending order gives us <code>[0, 1, 2, 3, 4, 6, 7, 8, 9]</code>. If we want to check if the number 5 is in the list, we now have a few ways we can go about it.</p>

		  <p>A method that would work on both the sorted and unsorted version of the list is the brute force method where we look at every element of the list, starting from the left side and going right, and check if they are equal to 5. For an unsorted list, this makes sense because there is always the possibility that the next element in the list is 5. For a sorted list, this seems silly because you end up doing a number of unnecessary checks. For example, if you start from the left most element, which is 0, and move right, you will eventually reach the number 6. Sorting in acending order means that every number to the right of 6 are equal to or great than 6, which means that 5 cannot be to the right of 6. Stopping our search here would save us 3 comparisions <code>(7, 8, 9)</code>.</p>

		  <p>If we stared from the right most element, which is the number 9, and moved left, we would eventually reach the number 4. Ascending order also mean that all the elements left of 4 are equal to or less than 4, which means that 5 cannot be to the left of 4. Stpping our search here would save us 4 comparisons <code>(0, 1, 2, 3)</code>.</p>

		    <p>Given how much the rules of ascending order tells us about the list, there is no harm in starting our search from an arbitrary location. For example, if we started our search in th middle of the list, which is at number 4, we know that if the number 5 is in the list, then it would be to the right of number 4, This means that our search algorithm now knows what direction to continue its search in. If your search algorithm decided to check the element to the right of 4, it will see the number 6 and know that 5 cannot be in this list. In this scenario, our algorithm just saved us 7 comparisons all because we understood how the list was ordered.</p>
		  
		</section>
	</body>
</html>
